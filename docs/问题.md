
### ⚠️ **Issues & Suggestions**

#### 1. **Potential Panic on Multiple `StopCleanupTask()` Calls**

```go
func (cam *CacheAffinityManager) StopCleanupTask() {
    close(cam.stopCh)  // Panic if called twice!
}
```

**Fix:** Add a guard or use `sync.Once`:

```go
func (cam *CacheAffinityManager) StopCleanupTask() {
    select {
    case <-cam.stopCh:
        // Already closed
    default:
        close(cam.stopCh)
    }
}
```

#### 2. **Cleanup Task Not Started Automatically**

`NewCacheAffinityManager()` creates the manager but does NOT start the cleanup task. You call `StartCleanupTask()` separately in `Start()`. This is fine but consider:
- If `StartCleanupTask()` is called multiple times, you'll spawn multiple goroutines

**Suggestion:** Add a `started` flag or use `sync.Once` to prevent multiple starts.

#### 3. **Debug Logging via `fmt.Printf`**

All the `fmt.Printf` statements (e.g., lines 82, 96, 116, 128, etc.) are good for debugging but may be noisy in production:

```go
fmt.Printf("[CacheAffinity] 缓存命中: %s → %s (count: %d)\n", ...)
```

**Suggestion:** Consider using a structured logger with configurable log levels, or at least add a debug flag.

#### 4. **Lock Contention in `Get()`**

The `Get()` function acquires the write lock just to increment `RequestCount`:

```go
// Line 92-99
cam.mu.Lock()
if aff, ok := cam.store[key]; ok {
    aff.RequestCount++
    fmt.Printf(...)
}
cam.mu.Unlock()
```

**Impact:** This creates write lock contention on every cache hit, which could become a bottleneck under high load.

**Suggestions:**
- Use `atomic.AddInt64` for the counter instead
- Or accept that counts may be approximate and skip incrementing on reads

#### 6. **Duplicated Cache Logic Across 3 Handlers**

The cache affinity logic is copy-pasted across:
- `proxyHandler()` (lines 602-675)
- `geminiProxyHandler()` (lines 1441-1489)  
- `customCliProxyHandler()` (lines 2033-2103)

**Suggestion:** Extract into a helper method like:

```go
func (prs *ProviderRelayService) tryAffinityProvider(
    affinityKey string, 
    providers []Provider, 
    forwardFn func(*Provider) (bool, error),
) (handled bool, usedProvider string)
```

#### 7. **Edge Case: Empty Model Name**

If `requestedModel` is empty, the affinity key becomes `{userID}:{platform}:` which may lead to unintended cache collisions.

```go
affinityKey := GenerateAffinityKey(userID, kind, requestedModel)
```

**Suggestion:** Add a guard or use a sentinel value for empty model names.
